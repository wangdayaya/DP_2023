# 前言
大模型的`多轮问答`难点就是在于如何精确识别用户最新的提问的`真实意图`，而在常见的使用大模型进行多轮对话方式中，我接触到的只有`两种方式`：
- 一种是简单地直接使用 `user` 和 `assistant` 两个角色将一问一答的会话内容喂给大模型，让它能够结合最新的问题靠自己去理解用户的最新的问题的含义。
- 另外一种方式是在会话过程中将历史的问题进行维护，再使用另外一个大模型结合最新的问题去理解用户当前的意图。

两种方式都可以，但是在我目前的业务上我目前使用的是`后者`，因为比较容易实现，效果也不错。

# 第一种方式

这是使用的是 `qwen` 的多轮问答 api ，要使用这一种方式，需要维护一个相当长的历史会话记录 `messages` ，而且要保证` messages` 中的 `user/assistant` 消息交替出现，这是一个必须要遵循的条件，如果是碰到异常，必须要对 messages 中最后的无效对话进行清理。这里就是将理解用户意图和解决用户的问题都混在了一块，对于我要做的业务，回答内容的不确定性太高，而且实现成本也高，需要在会话中加入大量业务代码，所以果断放弃了。

这里的代码主要实现了一个简易地关于烹饪的对话，只有两轮，实现逻辑比较简单，写的比较粗糙，理解意思即可。

```
def multi_round():
    messages = [{'role': 'system', 'content': '你是一个绝佳的烹饪助手'},
                {'role': 'user', 'content': '如何做西红柿炖牛腩？'}]
    response = Generation.call(model="qwen-turbo",  messages=messages, result_format='message')
    if response.status_code == HTTPStatus.OK:
        print(response)
        messages.append({'role': response.output.choices[0]['message']['role'],
                         'content': response.output.choices[0]['message']['content']})   # 将assistant的回复添加到messages列表中
    else:
        print(response.message)
        messages = messages[:-1]  # 如果响应失败，将最后一条user message从messages列表里删除，确保 user/assistant 消息交替出现
    messages.append({'role': 'user', 'content': '不放糖可以吗？'})  # 将新一轮的user问题添加到messages列表中
    
    response = Generation.call(model="qwen-turbo", messages=messages, result_format='message', )
    if response.status_code == HTTPStatus.OK:
        print(response)
        messages.append({'role': response.output.choices[0]['message']['role'],
                         'content': response.output.choices[0]['message']['content']})  # 将第二轮的assistant的回复添加到messages列表中
    else:
        print(response.message)
        messages = messages[:-1]  # 如果响应失败，将最后一条user message从messages列表里删除，确保 user/assistant 消息交替出现
```


# 第二种方式

在我所做地业务中，对于 `assistant` 的回复不关心，主要关心的是`用户的问题`，所以我只关注 `user` 的历史提问，在实现的时候只需要维护一个列表 `history`，始终将最新的用户提问追加即可，为了保证列表信息的有效性，我始终只维护最后 `10` 个问题。我这里使用 `qwen-max` 模型对历史提问进行总结，并且按照我要求的方式进行输出。也就是说这个模型只负责总结历史问题，对于业务问题的回答是其他大模型干的事情，任务分工明确就减少了不确定性。

```
history = []
@app.route('/getAnwser', methods=["POST"])
def getAnwser():
    data = request.get_json()
    question = data['question']
    global history
    history.append(question)
    history = history[-10:]  # 始终只维护最后 10 个问题
    print("正在解析用户意图...\n\n")
    try:
        # 将 history 拼接成字符串传入 prompt 中
        history_str = ""
        if history:
            history_str = '['
            for h in history:
                history_str += f"'{h}',"
            history_str.strip(",")
            history_str += ']'
        messages = [
            {'role': 'system', 'content': '您是一名精通总结多轮问题含义的助手，请根据历史问题做出有效的判断，帮我总结最新的问题，保证不会丢失关键信息，需要注意的是越靠近新的对话越重要'},
            {'role': 'user', 'content': f"历史上我依次提问了以下问题：{history_str}，请帮我总结出我最新的问题，不要做冗余的解释或者赘述。如果用户提出的问题语义模糊不清无法识别，可以直接返回空字符串。答案的模板必循遵循”【{{我的最新的问题描述}}】“"}
        ]
        response = Generation.call(model="qwen-max", messages=messages, result_format='message')
        if response.status_code == HTTPStatus.OK:
            resp = response.output.choices[0]['message']['content'].replace("【", "").replace("】", "")
        else:
            raise Exception("接口限流，请稍后重试。")
        print(f"您的最新问题是：{resp} \n\n")
    except BaseException as e:
        if history:
            history = history[:-1]  # 异常时候，将本次新增的问题删除
        print( f"Error: {str(e)}\n\n".encode())
```




